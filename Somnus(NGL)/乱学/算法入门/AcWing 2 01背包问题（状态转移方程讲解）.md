
## AcWing 2. 01背包问题（状态转移方程讲解）
[原题链接](https://www.acwing.com/problem/content/description/2/)
简单

---

[[3 完全背包问题 - AcWing题库]]

21.2.10更新：

- 代码变量命名与题目一致
在有限的背包容量下，装入的物品总价值最大。

「0-1 背包」是较为简单的动态规划问题，也是其余背包问题的基础。

动态规划是不断决策求最优解的过程，「0-1 背包」即是不断对第 i*ii* 个物品的做出决策，「0-1」正好代表不选与选两种决定。

## 2. 题解代码（C++）

### 2.1 版本1 二维

（1）状态`f[i][j]`定义：**前 i** 个物品，背包容量 j 下的最优解（最大价值）：

- 当前的状态依赖于之前的状态，可以理解为从初始状态`f[0][0] = 0`开始决策，有 N*NN* 件物品，则需要 N*NN* 次决 策，每一次对第 i*ii* 件物品的决策，状态`f[i][j]`不断由之前的状态更新而来。

（2）当前背包容量不够（`j < v[i]`），没得选，因此前 i*ii* 个物品最优解即为前 i−1*i* − 1*i* − 1 个物品最优解：

- 对应代码：`f[i][j] = f[i - 1][j]`。

（3）当前背包容量够，可以选，因此需要决策选与不选第 i*ii* 个物品：

- 选：`f[i][j] = f[i - 1][j - v[i]] + w[i]`。
- 不选：`f[i][j] = f[i - 1][j]` 。
- 我们的决策是如何取到最大价值，因此以上两种情况取 `max()` 。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1005;
int v[MAXN];    // 体积
int w[MAXN];    // 价值
int f[MAXN][MAXN];  // f[i][j], j体积下前i个物品的最大价值
int main()
{    int n, m;
    cin >> n >> m;    
    for(int i = 1; i <= n; i++)
        cin >> v[i] >> w[i];    
		    for(int i = 1; i <= n; i++){    //通过递归解决问题
        for(int j = 1; j <= m; j++){            
            //  当前背包容量装不进第i个物品，则价值等于前i-1个物品            
            if(j < v[i]){   //这里是先考虑能不能把第i个放进去，再进行递归求解
                f[i][j] = f[i - 1][j];     
                }       // 能装，需进行决策是否选择第i个物品            
                else
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);        }
    cout << f[n][m] << endl;    
    return 0;
    }
```

---

### 2.2 版本2 一维

将状态`f[i][j]`优化到一维`f[j]`，实际上只需要做一个**等价变形**。

为什么可以这样变形呢？我们定义的状态`f[i][j]`可以求得任意合法的`i`与`j`最优解，但**题目只需要求得最终状态`f[n][m]`，因此我们只需要一维的空间来更新状态。**

（1）状态`f[j]`定义：N 件物品，背包容量`j`下的最优解。

（2）**注意枚举背包容量`j`必须从`m`开始。**

（3）**为什么一维情况下枚举背包容量需要逆序？**在二维情况下，状态`f[i][j]`是由上一轮`i - 1`的状态得来的，`f[i][j]`与`f[i - 1][j]`是独立的。而优化到一维后，如果我们还是正序，则有`f[较小体积]`更新到`f[较大体积]`，则有可能本应该用第`i-1`轮的状态却用的是第`i`轮的状态。

（4）例如，一维状态第`i`轮对体积为 333 的物品进行决策，则`f[7]`由`f[4]`更新而来，这里的`f[4]`正确应该是`f[i - 1][4]`，但从小到大枚举`j`这里的`f[4]`在第`i`轮计算却变成了`f[i][4]`。当逆序枚举背包容量`j`时，我们求`f[7]`同样由`f[4]`更新，但由于是逆序，这里的`f[4]`还没有在第`i`轮计算，所以此时实际计算的`f[4]`仍然是`f[i - 1][4]`。

（5）简单来说，一维情况正序更新状态`f[j]`需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。

状态转移方程为：`f[j] = max(f[j], f[j - v[i]] + w[i]` 。实际上这里的f[j-v[i]]``` 就相当于来自于上一个物品(i-1)的状态。这样向后遍历.


```cpp
for(int i = 1; i <= n; i++)
    for(int j = m; j >= 0; j--)    {
        if(j < v[i])
            f[i][j] = f[i - 1][j];  // 优化前            
            f[j] = f[j];            // 优化后，该行自动成立，可省略。
        else
            f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);  // 优化前                 
            f[j] = max(f[j], f[j - v[i]] + w[i]);                   // 优化后    }
```

实际上，只有当枚举的背包容量 `>= v[i]` 时才会更新状态，因此我们可以修改循环终止条件进一步优化。

```cpp
for(int i = 1; i <= n; i++){
    for(int j = m; j >= v[i]; j--)
        f[j] = max(f[j], f[j - v[i]] + w[i]);}
```

### 关于状态`f[j]`的补充说明

二维下的状态定义`f[i][j]`是前 i*ii* 件物品，背包容量 j*jj* 下的最大价值。一维下，少了前 i*ii* 件物品这个维度，我们的代码中决策到第 i*ii* 件物品（循环到第`i`轮），`f[j]`就是前`i`轮已经决策的物品且背包容量 j*jj* 下的最大价值。

因此当执行完循环结构后，由于已经决策了所有物品，`f[j]`就是所有物品背包容量 j*jj* 下的最大价值。即一维`f[j]`等价于二维`f[n][j]`。

### 2.3 版本3 优化输入

我们注意到在处理数据时，我们是一个物品一个物品，一个一个体积的枚举。

因此我们可以不必开两个数组记录体积和价值，而是边输入边处理。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1005;
int f[MAXN];
int main(){    
	int n, m;
    cin >> n >> m;    
    for(int i = 1; i <= n; i++) {        
	    int v, w;        
	    cin >> v >> w;      // 边输入边处理        
	    for(int j = m; j >= v; j--)            
		    f[j] = max(f[j], f[j - v] + w);    
		    }    
	cout << f[m] << endl;    
	return 0;
}
```



